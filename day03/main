#!/usr/bin/env ruby

left, right = $<.read.lines.map{ |line| line.split(",").map(&:strip) }

# left = %w(R8 U5 L5 D3)
# right = %w(U7 R6 D4 L4)

# left = %w(R75 D30 R83 U83 L12 D49 R71 U7 L72)
# right = %w(U62 R66 U55 R34 D71 R55 D58 R83)

# left = %w(R98 U47 R26 D63 R33 U87 L62 D20 R33 U53 R51)
# right = %w(U98 R91 D20 R16 D67 R40 U7 R15 U6 R7)

Point = Struct.new(:x, :y, :steps)

class Line
  attr_reader :p1, :p2

  def initialize(point1, point2)
    @p1 = point1
    @p2 = point2
  end

  def intersect(other)
    a1 = @p2.y - @p1.y
    b1 = @p1.x - @p2.x
    c1 = a1 * @p1.x + b1 * @p1.y

    a2 = other.p2.y - other.p1.y
    b2 = other.p1.x - other.p2.x
    c2 = a2 * other.p1.x + b2 * other.p1.y

    delta = a1 * b2 - a2 * b1

    # puts delta
    return nil if delta == 0

    x = (b2 * c1 - b1 * c2) / delta
    y = (a1 * c2 - a2 * c1) / delta
    Point.new(x, y, 0)
  end

  def to_s
    "#{@x},#{@y}"
  end
end


def parse_path(input)
  a = Point.new(0, 0, 0)
  input.map do |direction|
    len = direction[1..-1].to_i
    b = case direction[0]
    when "R"
      Point.new(a.x + len , a.y, len)
    when "L"
      Point.new(a.x - len, a.y, len)
    when "U"
      Point.new(a.x, a.y + len, len)
    when "D"
      Point.new(a.x, a.y - len, len)
    end
    old_a = a
    a = b
    [old_a, b]
  end
end

def on_segment(p, q, r)
  q.x <= [p.x, r.x].max && q.x >= [p.x, r.x].min && q.y <= [p.y, r.y].max && q.y >= [p.y, r.y].min
end

def orientation(p, q, r)
  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
  return 0 if val.zero?
  # clock or counterclock wise
  val > 0 ? 1 : 2
end

def intersect?(p1, q1, p2, q2)
  o1 = orientation(p1, q1, p2)
  o2 = orientation(p1, q1, q2)
  o3 = orientation(p2, q2, p1)
  o4 = orientation(p2, q2, q1)

  # General case
  return true if o1 != o2 && o3 != o4
  return true if o1.zero? && on_segment(p1, p2, q1)
  return true if o2.zero? && on_segment(p1, q2, q1)
  return true if o3.zero? && on_segment(p2, p1, q2)
  return true if o4.zero? && on_segment(p2, q1, q2)
  false
end

# puts parse_path(left).map(&:inspect)
# puts
# puts parse_path(right).map(&:inspect)

list1 = parse_path(left)
list2 = parse_path(right)

manhattans = []
list1.each do |point1, point2|
  list2.each do |other1, other2|
    if intersect?(point1, point2, other1, other2)
      val = Line.new(point1, point2).intersect(Line.new(other1, other2))
      if val
        manhattans << val.x.abs + val.y.abs
        # puts val.x.abs + val.y.abs
      end
    end
  end
end

puts manhattans.reject(&:zero?).min
