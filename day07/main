#!/usr/bin/env ruby

class Amplifier
  def initialize(program, *input, halt_on_write: false)
    @program = program.clone
    @input = input.clone
    @halt_on_write = halt_on_write
    @output = []
    @failed = false
    @idx = 0
  end

  def run(*input)
    @input += input if input.any?
    while !halted?
      a, b, c = @program[@idx + 1, 3]
      a = @program[a] if @program[@idx].div(100).modulo(10).zero?
      b = @program[b] if @program[@idx].div(1000).modulo(10).zero?
      case intcode
      when 1 # add
        @program[c] = a + b
        @idx += 4
      when 2 # multiply
        @program[c] = a * b
        @idx += 4
      when 3 # read
        @program[@program[@idx + 1]] = @input.shift
        @idx += 2
      when 4 # write
        @output << @program[@program[@idx + 1]]
        @idx += 2
        return @output.last if @halt_on_write
      when 5 # jump if true
        @idx = a != 0 ? b : @idx + 3
      when 6 # jump if false
        @idx = a.zero? ? b : @idx + 3
      when 7 # less than
        @program[c] = a < b ? 1 : 0
        @idx += 4
      when 8 # equals
        @program[c] = a == b ? 1 : 0
        @idx += 4
      else
        puts "program failed"
        @failed = true
        return nil
      end
    end
    return @output.last
  end

  def last_output
    @output.last
  end

  def halted?
    intcode == 99 || failed?
  end

  def failed?
    @failed
  end

  private

  def intcode
    @program[@idx] % 100
  end
end

def calculate_thrust(input, phases)
  phases.reduce(0) { |signal, phase| Amplifier.new(input, phase, signal).run }
end

# Create amplifiers and chain them so they create a feedback loop
def calculate_feedback_loop(input, phases)
  amps = phases.map { |phase| Amplifier.new(input, phase, halt_on_write: true) }
  initial = 0
  while !amps.last.halted? do
    initial = amps.reduce(initial) { |val, amp| amp.run(val) }
  end
  amps.last.last_output
end

def main
  input = $<.read.split(",").map(&:to_i)
  puts "Part 1"
  puts 5.times.to_a.permutation.map { |phases| calculate_thrust(input, phases) }.max
  puts "Part 2"
  puts (5..9).to_a.permutation.map { |phases| calculate_feedback_loop(input, phases) }.max
end

main
