#!/usr/bin/env ruby

class Amplifier
  def initialize(program, *input)
    @program = program.clone
    @next_amp = nil
    @input = input.clone
    @output = []
    @failed = false
    @idx = 0
  end

  def run
    while !halted?
      a, b, c = @program[@idx + 1, 3]
      a = @program[a] if @program[@idx].div(100).modulo(10).zero?
      b = @program[b] if @program[@idx].div(1000).modulo(10).zero?
      case intcode
      when 1 # add
        @program[c] = a + b
        @idx += 4
      when 2 # multiply
        @program[c] = a * b
        @idx += 4
      when 3 # read
        @program[@program[@idx + 1]] = @input.shift
        @idx += 2
      when 4 # write
        @output << @program[@program[@idx + 1]]
        @idx += 2
        # Send output to the next amplifier.
        @next_amp&.append_input(@output.last)
        @next_amp&.run
        return @next_amp.last_output if @next_amp&.halted?
      when 5 # jump if true
        @idx = a != 0 ? b : @idx + 3
      when 6 # jump if false
        @idx = a.zero? ? b : @idx + 3
      when 7 # less than
        @program[c] = a < b ? 1 : 0
        @idx += 4
      when 8 # equals
        @program[c] = a == b ? 1 : 0
        @idx += 4
      else
        puts "program failed"
        @failed = true
        return nil
      end
    end
    return @output.last
  end

  def append_input(val)
    @input << val
  end

  def chain(amp)
    @next_amp = amp
  end

  def last_output
    @output.last
  end

  def halted?
    intcode == 99 || failed?
  end

  def failed?
    @failed
  end

  private

  def intcode
    @program[@idx] % 100
  end
end

def calculate_thrust(input, phases)
  phases.reduce(0) { |signal, phase| Amplifier.new(input, phase, signal).run }
end

# Create amplifiers and chain them so they create a feedback loop
def calculate_feedback_loop(input, phases)
  a, b, c, d, e = phases.map { |phase| Amplifier.new(input, phase) }
  a.chain(b).chain(c).chain(d).chain(e).chain(a)
  a.append_input(0)
  a.run
  e.last_output
end

def main
  input = $<.read.split(",").map(&:to_i)
  puts "Part 1"
  puts 5.times.to_a.permutation.map { |phases| calculate_thrust(input, phases) }.max
  puts "Part 2"
  puts (5..9).to_a.permutation.map { |phases| calculate_feedback_loop(input, phases) }.max
end

main
